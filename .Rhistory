scale_x_continuous(limits = c(min(df.results.minor$CAGR),  max(df.results.minor$CAGR))) +
theme(legend.position="bottom")
plot.stacked
grid.arrange(plot,plot.stacked,ncol = 1)
plot.stacked = ggplot(data = melted.pareto.minor,
aes(x = CAGR,y = value,fill = variable)) +
geom_bar(stat = "identity",width=.0001) +
scale_x_continuous(limits = c(min(df.results.minor$CAGR),  max(df.results.minor$CAGR))) +
theme(legend.position="bottom")
plot.stacked
grid.arrange(plot,plot.stacked,ncol = 1)
plot.stacked = ggplot(data = melted.pareto.minor,
aes(x = CAGR,y = value,fill = variable)) +
geom_bar(stat = "identity",width=.005) +
scale_x_continuous(limits = c(min(df.results.minor$CAGR),  max(df.results.minor$CAGR))) +
theme(legend.position="bottom")
grid.arrange(plot,plot.stacked,ncol = 1)
c
save(data = df.results.minor,file = "df.harrybrowne.rda")
save(data = df.results.minor,file = "df.10_harrybrowne_spectrum.rda")
pareto.minor
load("df.10_harrybrowne_spectrum.rda")
pareto.minor = psel(df.results.minor, high(CAGR) * low(DD))
melted.pareto.minor = melt(pareto.minor,id = c("CAGR","DD"))
plot = ggplot() +
geom_point(data = df.results.minor,aes(x = CAGR,y = DD),colour = "gray") +
geom_point(data = pareto.minor,aes(x = CAGR,y = DD),colour = "orange")
plot.stacked = ggplot(data = melted.pareto.minor,
aes(x = CAGR,y = value,fill = variable)) +
geom_bar(stat = "identity",width=.005) +
scale_x_continuous(limits = c(min(df.results.minor$CAGR),  max(df.results.minor$CAGR))) +
theme(legend.position="bottom")
plot
plot.stacked
grid.arrange(plot,plot.stacked,ncol = 1)
library(ggplot2)  # for ggplot
library(rPref)    # for psel
library(reshape2) # for melt
library(gridExtra)
load("df.10_harrybrowne_spectrum.rda")
pareto.minor = psel(df.results.minor, high(CAGR) * low(DD))
melted.pareto.minor = melt(pareto.minor,id = c("CAGR","DD"))
plot = ggplot() +
geom_point(data = df.results.minor,aes(x = CAGR,y = DD),colour = "gray") +
geom_point(data = pareto.minor,aes(x = CAGR,y = DD),colour = "orange")
plot.stacked = ggplot(data = melted.pareto.minor,
aes(x = CAGR,y = value,fill = variable)) +
geom_bar(stat = "identity",width=.005) +
scale_x_continuous(limits = c(min(df.results.minor$CAGR),  max(df.results.minor$CAGR))) +
theme(legend.position="bottom")
grid.arrange(plot,plot.stacked,ncol = 1)
df.results.minor
save(data = df.results.minor,file = "df.10_harrybrowne_spectrum.rda")
getwd()
setwd("D:/Github/retirement-planner/Harry Browne")
getwd()
rm(list=ls())
library(readxl)
library(quantmod)
directory = "D:/Github/DataDrivenTrading/"
data_path = "D:/Github/DataDrivenTrading/Data/OHLC/"
setwd(directory)
# Load list of instruments
df <- data.frame(read_excel("etfdb_data.xls"))
colnames(df) = c("symbol","name","etfdb.category","inception.date","expense.ratio","commission.free","expenses.rating")
# Check file checker to determine which instruments need to be updated
existing.files = list.files("./Data/OHLC",full.names = FALSE) # fetch list of all files from folder
existing.files = gsub(".csv","",existing.files) # remove ".csv" from vector of characters
# The update list determines if the file needs to be updated
df.updatelist = data.frame(stringsAsFactors=FALSE)
df.old.log = read.csv("log.csv")
df.old.log
df.log
df.old.log = read.csv("log.csv")
df.old.log
head(df.old.log)
df
existing.files
df.old.log
?boolean
df.updatelist = data.frame("target.symbol" = character(),
"already.exists" = logic(),
stringsAsFactors=FALSE)
df.updatelist = data.frame("target.symbol" = character(),
"already.exists" = boolean(),
stringsAsFactors=FALSE)
# The update list determines if the file needs to be updated
df.updatelist = data.frame("target.symbol" = character(),
"already.exists" = logical(),
stringsAsFactors=FALSE)
df.updatelist
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df$symbol,
"already.exists" = logical(),
"already.updated" = logical(),
stringsAsFactors=FALSE)
df.comparison = data.frame("target.symbol" = character(),
"already.exists" = logical(),
"already.updated" = logical(),
stringsAsFactors=FALSE)
existing.files
"MOAT" %in% df.old.log$fetched.symbol
"moat" %in% df.old.log$fetched.symbol
# Reads in last update information
df.existing = read.csv("log.csv")
df.existing
head(df.existing)
df.target
df.target <- data.frame(read_excel("etfdb_data.xls"))
colnames(df.target) = c("symbol","name","etfdb.category","inception.date","expense.ratio","commission.free","expenses.rating")
df.comparison
df.comparison$target.symbol = df.target$symbol
?vector
df.comparison = data.frame("target.symbol" = df.target$symbol,
"already.exists" = rep(NA,nrow(df.target)),
"already.updated" = rep(NA,nrow(df.target)),
stringsAsFactors=FALSE)
df.comparison
head(df.comparison)
for (i in 1:nrow(df.comparison)){
df.comparison$already.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
}
df.comparison
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = rep(NA,nrow(df.target)),
stringsAsFactors=FALSE)
Sys.Date()
Sys.Date() == Sys.Date()
df.existing
grep(df.target$symbol[3],df.existing$fetched.symbol)
df.existing$fetch.attempted = [grep(df.target$symbol[3],df.existing$fetched.symbol)]
df.existing$fetch.attempted[grep(df.target$symbol[3],df.existing$fetched.symbol)]
df.existng
df.existing
class(df.existing$fetched.symbol)
# Reads in last update information
df.existing = read.table("log.csv", stringsAsFactors=False)
# Reads in last update information
df.existing = read.table("log.csv", stringsAsFactors=F)
df.existing
class(df.existing)
head(df.existing)
?read.table
df.existing = read.table("log.csv",header = TRUE,sep = ",", stringsAsFactors=F)
df.existing
head(df.existing)
class(df.existing$fetch.attempted)
# Reads in last update information
df.existing = read.table("log.csv",header = TRUE,sep = ",", stringsAsFactors=F)
head(df.existing)
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
df.comparison$target.updated[i] = Sys.Date() == df.existing$fetched.date[grep(df.target$symbol[3],df.existing$fetched.symbol)]
}
df.comparison
View(df.comparison)
df.comparison$target.exists | df.comparison$target.updated
df.comparison$target.exists $ df.comparison$target.updated
df.comparison$target.exists & df.comparison$target.updated
df.comparison["needs.update"] = df.comparison$target.exists & df.comparison$target.updated
df.comparison
head(df.comparison)
df.comparison["needs.update"] = !df.comparison$target.exists & df.comparison$target.updated
df.comparison
head(df.comparison)
df.comparison["needs.update"] = !(df.comparison$target.exists & df.comparison$target.updated)
head(df.comparison)
subset(df.comparison,needs.update == TRUE)
subset(df.comparison$target.symbol,needs.update == TRUE)
subset(df.comparison,needs.update == TRUE)
?subset
subset(df.comparison,needs.update == TRUE)$symbol
subset(df.comparison,needs.update == TRUE)
head(subset(df.comparison,needs.update == TRUE))
head(subset(df.comparison,needs.update == TRUE))$target.symbol
subset(df.comparison,needs.update == TRUE)$target.symbol
df.comparison
head(df.comparison)
i in subset(df.comparison,needs.update == TRUE)$target.symbol)
i in subset(df.comparison,needs.update == TRUE)$target.symbol
for (i in subset(df.comparison,needs.update == TRUE)$target.symbol){}
for (i in subset(df.comparison,needs.update == TRUE)$target.symbol){print "hello"}
for (i in subset(df.comparison,needs.update == TRUE)$target.symbol){x = x + i}
head(df.comparison)
?write.table
?write.zoo
?write.table
rm(list=ls())
library(readxl)
library(quantmod)
directory = "D:/Github/DataDrivenTrading/"
data_path = "D:/Github/DataDrivenTrading/Data/OHLC/"
setwd(directory)
# Reads in last update information
df.existing = read.table("log.csv",header = TRUE,sep = ",", stringsAsFactors=F)
# Load list of target instruments
df.target <- data.frame(read_excel("etfdb_data.xls"))
colnames(df.target) = c("symbol","name","etfdb.category","inception.date","expense.ratio","commission.free","expenses.rating")
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = rep(NA,nrow(df.target)),
stringsAsFactors=FALSE)
# Perform comparisons to determine if target instrument exists and if it is updated
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
df.comparison$target.updated[i] = Sys.Date() == df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
}
# If target instrument does not exist or if it not updated, it should be re-scraped
df.comparison["needs.update"] = !(df.comparison$target.exists & df.comparison$target.updated)
df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)
df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
df.existing$fetched.date
[grep(df.target$symbol[i],df.existing$fetched.symbol)]
grep(df.target$symbol[i],df.existing$fetched.symbol)
i
grep(df.target$symbol[10],df.existing$fetched.symbol)
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
df.comparison$target.updated[i] = try(Sys.Date() == df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)])
}
df.comparison
Sys.Date() == df.existing$fetched.date
df.existing$fetched.date[316] = TRUE
df.existing$fetched.date
df.existing$fetched.date[316] = as.Date("2016-10-03")
df.existing$fetched.date
"2016-10-02" == df.existing$fetched.date
# Reads in last update information
df.existing = read.table("log.csv",header = TRUE,sep = ",", stringsAsFactors=F)
# Load list of target instruments
df.target <- data.frame(read_excel("etfdb_data.xls"))
colnames(df.target) = c("symbol","name","etfdb.category","inception.date","expense.ratio","commission.free","expenses.rating")
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
# Perform comparisons to determine if target instrument exists and if it is updated
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
}
rm(list=ls())
library(readxl)
library(quantmod)
directory = "D:/Github/DataDrivenTrading/"
data_path = "D:/Github/DataDrivenTrading/Data/OHLC/"
setwd(directory)
# Reads in last update information
df.existing = read.table("log.csv",header = TRUE,sep = ",", stringsAsFactors=F)
# Load list of target instruments
df.target <- data.frame(read_excel("etfdb_data.xls"))
colnames(df.target) = c("symbol","name","etfdb.category","inception.date","expense.ratio","commission.free","expenses.rating")
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
# Perform comparisons to determine if target instrument exists and if it is updated
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
}
df.comparison
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
df.target <- data.frame(read_excel("etfdb_data.xls"))
df.target
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
df.target
df.target$symbol
nrow(df.target$symbol)
class(df.target$symbol)
# Create a dataframe that contains information on what data to fetch
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
nrow(df.target)
nrow(df.target$symbol)
df.target$symbol
p = df.target$symbol
nrow(p)
length(p)
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,length(df.target)),
"target.updated" = Sys.Date() == df.existing$fetched.date,
stringsAsFactors=FALSE)
df.target$symbol
length(df.target$symbol)
df.comparison = data.frame("target.symbol" = df.target$symbol,
"target.exists" = rep(NA,nrow(df.target))
)
head(df.existing)
nrow(df.existing)
grep(df.target.symbol[i],df.existing$fetched.symbol)
grep(df.target$symbol[i],df.existing$fetched.symbol)
grep(df.target$symbol[100],df.existing$fetched.symbol)
for (i in 1:nrow(df.comparison)){
df.comparison$target.exists[i] = df.target$symbol[i] %in% df.existing$fetched.symbol
df.comparison$target.updated[i] = Sys.Date() == df.existing$fetched.date[grep(df.target$symbol[100],df.existing$fetched.symbol)]
}
for (i in 1:nrow(df.comparison)){
tryCatch({
if (target.exists == TRUE & target.updated == FALSE){
startDate = df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
from = startDate,
auto.assign = FALSE)
write.table(data,paste(data_path,ticker,".csv",sep = ""), append = TRUE, sep = ",")
}
if (target.exists == FALSE){
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
auto.assign = FALSE)
colnames(data) = c("open","high","low","close","volume","adjusted")
write.zoo(data,paste(data_path,ticker,".csv",sep = ""),sep=",",row.names=FALSE) # sep = "" to get rid of space in paste operations
# when successful write status to log
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
},
# when there is an error, write error
error = function(e) {
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"failure")
})
}
# Recreate log
df.log = data.frame("fetched.symbol" = character(),
"fetched.date" = as.Date(character()),
"fetched.status" = character(),
stringsAsFactors=FALSE)
# If target exists and the target is updated, do nothing
# If target exists and the target is not updated, append data to existing CSV from last fetched date
# If target does not exist, scrape
for (i in 1:nrow(df.comparison)){
tryCatch({
if (target.exists == TRUE & target.updated == FALSE){
startDate = df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
from = startDate,
auto.assign = FALSE)
write.table(data,paste(data_path,ticker,".csv",sep = ""), append = TRUE, sep = ",")
}
if (target.exists == FALSE){
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
auto.assign = FALSE)
colnames(data) = c("open","high","low","close","volume","adjusted")
write.zoo(data,paste(data_path,ticker,".csv",sep = ""),sep=",",row.names=FALSE) # sep = "" to get rid of space in paste operations
# when successful write status to log
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
},
# when there is an error, write error
error = function(e) {
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"failure")
})
}
# If target does not exist, scrape
for (i in 1:nrow(df.comparison)){
tryCatch({
if (target.exists == TRUE & target.updated == FALSE){
startDate = df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
from = startDate,
auto.assign = FALSE)
write.table(data,paste(data_path,ticker,".csv",sep = ""), append = TRUE, sep = ",")
}
if (target.exists == FALSE){
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
auto.assign = FALSE)
colnames(data) = c("open","high","low","close","volume","adjusted")
write.zoo(data,paste(data_path,ticker,".csv",sep = ""),sep=",",row.names=FALSE) # sep = "" to get rid of space in paste operations
# when successful write status to log
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
},
# when there is an error, write error
error = function(e) {
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"failure")
})
}
df.log
df.comparison
for (i in 1:nrow(df.comparison)){
tryCatch({
target.exists = df.comparison$target.exists[i]
target.updated = df.comparison$target.updated[i]
if (target.exists == TRUE & target.updated == FALSE){
startDate = df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
from = startDate,
auto.assign = FALSE)
write.table(data,paste(data_path,ticker,".csv",sep = ""), append = TRUE, sep = ",")
}
if (target.exists == FALSE){
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
auto.assign = FALSE)
colnames(data) = c("open","high","low","close","volume","adjusted")
write.zoo(data,paste(data_path,ticker,".csv",sep = ""),sep=",",row.names=FALSE) # sep = "" to get rid of space in paste operations
# when successful write status to log
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
},
# when there is an error, write error
error = function(e) {
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"failure")
})
}
df.log
df.log
df.log
data
library(quantmod)
for (i in 1:nrow(df.comparison)){
tryCatch({
target.exists = df.comparison$target.exists[i]
target.updated = df.comparison$target.updated[i]
if (target.exists == TRUE & target.updated == FALSE){
startDate = df.existing$fetched.date[grep(df.target$symbol[i],df.existing$fetched.symbol)]
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
from = startDate,
auto.assign = FALSE)
write.table(data,paste(data_path,ticker,".csv",sep = ""), append = TRUE, sep = ",")
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
if (target.exists == FALSE){
ticker = df.comparison$target.symbol[i]
data = getSymbols(Symbols = ticker,
src = "yahoo",
auto.assign = FALSE)
colnames(data) = c("open","high","low","close","volume","adjusted")
write.zoo(data,paste(data_path,ticker,".csv",sep = ""),sep=",",row.names=FALSE) # sep = "" to get rid of space in paste operations
# when successful write status to log
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"success")
}
},
# when there is an error, write error
error = function(e) {
df.log[nrow(df.log) + 1,] =c(i,as.character(Sys.Date()),"failure")
})
}
df.log
rm(list=ls())
library(readxl)
library(quantmod)
library(R.utils) # for countlines
directory = "C:/UserData/DataDrivenTrading/"
data_path = "C:/UserData/DataDrivenTrading/Data/OHLC/"
setwd(directory)
install.packages("R.utils")
countLines("D:/Github/DataDrivenTrading/Data/OHLC/CATH.csv")
?countlines
library(R.utils)
countLines("D:/Github/DataDrivenTrading/Data/OHLC/CATH.csv")
x = countLines("D:/Github/DataDrivenTrading/Data/OHLC/CATH.csv")
x
class(x)
x = countLines("D:/Github/DataDrivenTrading/Data/OHLC/CATH.csv")
x == 112
kaka = "D:/Github/DataDrivenTrading/Data/OHLC/CATH.csv"
read.csv(kaka,nrow = 1,skip = 112)
read.csv(kaka,nrow = 1,skip = 111)
read.csv(kaka,nrow = 1,skip = 110)
read.csv(kaka,nrow = 1,skip = 109)
read.csv(kaka,nrow = 1,skip = 110)
read.csv(kaka,nrow = 1,skip = 111)
read.csv(kaka,nrow = 1,skip = 110)
read.csv(kaka,nrow = 1,skip = 1)
read.csv(kaka,nrow = 1,skip = 0)
?read.csv
read.csv(kaka,header = FALSE, nrow = 1,skip = 0)
read.csv(kaka,header = TRUE, nrow = 1,skip = 0)
read.csv(kaka,header = TRUE, nrow = 1,skip = x)
read.csv(kaka,header = TRUE, nrow = 1,skip = 112)
read.csv(kaka,header = TRUE, nrow = 1,skip = 111)
read.csv(kaka,header = TRUE, nrow = 1,skip = 110)
read.csv(kaka,header = TRUE, nrow = 1,skip = 110)
read.csv(kaka,header = TRUE, nrow = 1,skip = 109)
read.csv(kaka,header = TRUE, nrow = 1,skip = 110)
read.csv(kaka,header = TRUE, nrow = 1,skip = 111)
read.csv(kaka,header = TRUE, nrow = 1,skip = 110)
read.csv(kaka,header = FALSE, nrow = 1,skip = 110)
read.csv(kaka,header = FALSE, nrow = 1,skip = 111)
read.csv(kaka,header = FALSE, nrow = 1,skip = 111)[1]
read.csv(kaka,header = FALSE, nrow = 1,skip = 111)[1]
